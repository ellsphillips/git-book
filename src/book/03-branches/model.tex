The model I demonstrate here, named \emph{git-flow} originates from 2010 -- not very long after Git itself came into being. It has become popular in its adoption and development in many software teams, perhaps even considered standard protocol. This model is geared more towards continuous delivery and integration, such as scheduled data releases, web development etc. where explicit versioning or multiple version support is required.

\vspace{11\baselineskip}%
\begin{figure}[H]
	\centering
	\noindent\resizebox{\textwidth}{!}{\input{src/book/03-branches/img-model}}
	\caption[A successful Git branching model]{Demonstration of the industry-standard \emph{git-flow} branching model.}
\end{figure}



\subsection{The main branches}

The central repo holds two main branches with an infinite lifetime, master and develop, where develop runs parallel to the master branch. By definition, consider these two branches for source code of HEAD as:

\begin{itemize}
	\item origin/master: always reflects a production-ready state.
	\item origin/develop: always reflects a state with the latest delivered development changes for the next release, enabling automatic production/CI builds overnight.
\end{itemize}

\vspace{6\baselineskip}%
\begin{figure}[H]
	\centering
	\noindent\resizebox{.66\textwidth}{!}{\input{src/book/03-branches/img-model-main}}
	\caption[Main branches]{Main branches \codeinline{master} and \codeinline{develop} of the \emph{git-flow} branching model.}
\end{figure}

When stable and release-ready, \codeinline{develop} branch source code is merged back into \codeinline{master} and tagged with a release number, generating a new production release \emph{by definition}. Keeping this strict enables use of Git hooks automatically build and roll-out software to our production servers per commit to \codeinline{master}.



\subsection{Supporting branches}

This development model’s supporting branches lay adjacent to the main branches \codeinline{master} and \codeinline{develop}, enabling;

\begin{itemize}
	\item Parallel development between team members,
	\item Ease of feature-tracking,
	\item Production release preparation,
	\item Effective fixing of live production problems
\end{itemize}

\noindent These branches are \codeinline{feature}, \codeinline{release}, and \codeinline{hotfix}. \newline

Unlike the main branches, these branches are designed to have finite lifetime, and each have a specific purpose and are bound to strict rules to accept particular branches as origin or target destination on merging.

Remember, all Git branches are technically the same – even \codeinline{master} is just an ordinary branch, created by default and most people opt to keep it – but instead these branch types are categorized by how we use them.



\subsection{Feature branches}

Feature branches are used to develop new features for the upcoming or a distant future release. They exist as long as the feature is in development and must either eventually be merged back into \codeinline{develop}, or discarded. \newline

\noindent Typically, feature branches exist in developer repos only, not in \codeinline{origin}. \newline

\noindent When starting work on a new feature, branch off from the \codeinline{develop} branch.

\begin{git-bash}[switch to new-feature branch]
    git checkout -b new-feature develop
\end{git-bash}

\noindent and when finished, features may be merged into \codeinline{develop} for inclusion in the upcoming release:

\begin{git-bash}[switch to new-feature branch]
    git checkout develop
    git merge --no-ff myfeature
    git branch -d myfeature
    git push origin develop
\end{git-bash}

Where the \codeinline{--no-ff flag} ensures the merge creates a new commit object, even if the merge could be performed with a fast-forward. This prevents information loss about the historical existence of a feature branch and groups together all commits that together added the feature.

\hfill\textcolor{red}{\ttfamily --no-ff demo}\hfill \newline

\noindent Whilst --no-ff creates a few more (empty) commit objects, it enables:

\begin{itemize}
	\item Visibility of commit objects together have implemented a feature in the Git history, eliminating laborious log messages traversal,
	\item Reverting a whole feature (i.e. a group of commits), with insight and reason from the Git history
\end{itemize}














